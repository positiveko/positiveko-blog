---
title: JavaScript | 함수형 언어는 무엇이 다른가?
author: Positive Ko
date: 2021-05-09
hero: ./images/hero.jpg
excerpt: 자바스크립트 닌자 비급 3장 요약
slug: whats-diff-of-functional-language
---

## 1. 함수형 언어는 무엇이 다른가?

### 1.1 함수형 언어 특징이 왜 중요한가?

자바스크립트의 함수형 언어 특징은 특히 브라우저에서 작동하도록 작성된 코드에서 더 중요하다.

자바스크립트에서 함수와 함수형 언어 특징이 중요한 이유 중 하나는, 함수가 실행의 기본 모듈 단위이기 때문이다.

**1종 객체로서의 함수**

자바스크립트의 객체는 다음과 같은 기능적 특징이 있다.

- 리터럴로 생성될 수 있다.
- 변수, 배열 엘리먼트, 다른 객체의 프로퍼티에 할당될 수 있다.
- 함수의 인자로 전달될 수 있다.
- 함수의 결과 값으로 반환될 수 있다.
- 동적으로 생성된 프로퍼티를 가질 수 있다.

## 2. 함수 선언

## 3. 호출

함수가 호출되는 방식은 코드 작동 방식에 큰 영향을 미치는데, 특히 this 매개변수가 어떻게 설정되는지를 결정한다. 

**함수를 호출하는 방법**

- 함수로 호출
- 메서드로 호출: 이 경우 호출과 객체는 서로 묶여있는데, 이는 객체 지향 프로그래밍을 가능케 한다.
- 생성자로 호출: 새로운 객체를 생성한다.
- apply(), call(): 조금 복잡하다.

### 3.1 인자(argument)에서 함수의 매개변수(parameter)까지

함수를 호출할 때 인자 목록을 제공하면, 이 인자들은 함수를 정의할 때 지정한 매개변수에 각 매개변수의 순서대로 할당된다. 

인자 개수와 매개변수의 개수가 다르더라도 에러는 발생하지 않는다. 

- 매개변수보다 많은 인자가 제공된다면, 남은 인자들은 매개변수에 할당되지 않는다.
- 인자보다 매개변수가 많을 경우, 인자와 부합하지 않는 매개변수는 undefined로 설정된다.

그리고 모든 함수 호출에는 암묵적으로 arguments와 this 두 매개 변수가 넘어온다.

**Arguments 매개변수**

arguments 매개변수는 함수에 전달된 모든 인자들을 담고 있는 컬렉션이다. 이 컬렉션은 인자 개수를 나타내는 length 프로퍼티를 가지고 있고, 배열 인덱스 표기법으로 개별 인자값을 얻을 수 있으며, for loop을 사용할 수 있다. 

하지만 argumnets 매개변수는 배열이 아닌 '유사배열'이다. Array와 다르게 배열 메서드 사용에 제한이 있다.

**This 매개변수**

함수를 호출할 때마다 명시적으로 주어진 인자를 나타내는 arguments 외에도, this라는 매개변수 또한 함수에 전달된다. 

this 매개변수는 암묵적으로 함수 호출과 관계된 객체를 참조하며, 이를 '함수 콘텍스트'라 한다.

자바 같은 객체 지향 언어의 개념을 따르면 this는 그 메서드가 정의되어 있는 클래스의 인스턴스를 가리키며, 함수 콘텍스트도 그렇게 이해할 수 있다. 

하지만 주의할 점은, '메서드' 호출은 함수를 호출할 수 있는 네 가지 방법 중 하나일 뿐이다. this 매개변수는 자바에서처럼 '어떤 식으로 함수를 정의하였나'가 아니라, 함수를 어떻게 '호출'할 것인가와 관련이 있다. 

### 3.2 함수로 호출

'함수로' 호출한다고 말하는 것은 다른 호출 매커니즘(메서드, 생성자, apply/call)과 구분하기 위한 것이다. 

'함수로 호출'하는 형식은 () 연산자를 사용하여 함수를 호출하는 것이다. 그리고 이 함수 호출 표현식에서 함수는 어떤 객체의 프로퍼티로 간주되지 않는다. 

```jsx
function ninja(){};
ninja();

const samurai = function(){};
samurai();
```

이 상태로 호출되었을 때, 함수 콘텍스트는 전역 콘텍스트(window 객체)이다. 

'함수로' 호출하는 경우, 암묵적으로 모든 함수의 소유자는 window객체다. '함수를 함수로 호출'한다는 이 개념은 '메서드로 호출'의 한 가지 케이스이다.

### 3.3 메서드로 호출

함수를 객체의 프로퍼티로 할당하고, 그 프로퍼티를 사용하여 '참조에 의한 호출'이 일어나면, 함수는 그 객체의 메서드로 호출된다. 

```jsx
const o = {};
o.whatever = function(){};
o.whatever();
```

위처럼 어떤 객체의 메서드로 함수를 호출하면, 그 객체는 함수 콘텍스트가 되고 함수 내에서 this 매개변수로 참조할 수 있다. 

이는 자바스크립트로 객체 지향 코드를 작성할 수 있게 하는 주요 수단 중 하나다.

이는 window 객체에 함수가 정의되고 window에 대한 참조를 사용할 필요가 없는 '함수로' 호출과는 대조적이다. 그러나 암묵적인 window 참조를 생략할 수 있다는 점만 제외하면 근본적으로는 같다. '함수로' 호출에서 함수는 window에 속하고, window는 함수 콘텍스트로 설정된다. 이는 위 예제에서 객체 o가 함수 콘텍스트가 되는 것과 같은 방식이다. 이 메커니즘들이 다르게 보이더라도 그것들은 실질적으로 같다. 

메서드로 함수를 호출했으 ㄹ때 함수 콘텍스트는 그 메서드를 가지고 있는 개체여야 한다. 이는 자바스크립트로 객체 지향 코드를 작성하는 데에 결정적인 역할을 한다. 또한 이는 객체 지향 프로그래밍의 기본 개념 중 하나로, 메서드를 소유하고 있는 객체를 참조하기 위해 어떤 메서드 내에서든 this를 사용할 수 있다는 것을 뜻한다. 

함수가 어떻게 정의되는냐가 아니라, '어떻게 호출되는냐'에 따라 각 호출에 대한 함수 콘텍스트가 변한다는 것을 유념하자.

```jsx

function creep(){return this;}
const log = console.log;

log(creep() === window); // true

const sneak = creep;
log(sneak() === window); // true

const ninja1 = {
  skulk: creep
}
log(ninja1.skulk() === ninja1); // true

const ninja2 = {
  skulk: creep
}
log(ninja2.skulk() === ninja2); // true
```

위에서 ninja1과 ninja2는 동일한 함수 인스턴스를 공유하고 있다. 하지만 함수가 실행되면 함수는 그 메서드가 호출된 객체에 접근하고, 그 메서드가 호출된 객체에 따라 필요한 연산을 수행한다. 이것은 서로 다른 객체라 하더라도 같은 처리를 수행하는 함수라면, 객체마다 별도의 함수 복사본을 생성할 필요가 없다는 것을 뜻한다. 이것은 객체 지향 프로그래밍의 신조이다. 

### 3.4 생성자로 호출

'생성자로' 함수를 호출하려면 함수 호출 앞에 new 키워드를 붙인다. 

```jsx
function creep(){ return this; }
new creep();
```

하지만 이 경우에 creep()함수는 생성자로 사용하기에는 적당하지 않다. 

**생성자의 강력함**

생성자로 함수를 호출하는 것은 자바스크립트만의 강력한 기능인데, 생성자가 호출되면 다음과 같은 특별한 행동이 일어나기 때문이다.

- 비어있는 객체가 새로 생성된다.
- 새로 생성된 객체는 this 매개변수로 생성자 함수에 전달되고, 따라서 생성자의 함수 콘텍스트가 된다.
- 어떤 명시적인 반환 값이 없다면, 새로 생성된 객체가 생성자의 값으로 반환된다.

이처럼 생성자의 목적은 새로 생성한 객체의 내용을 설정하고, 새 객체를 생성자의 값으로 반환하는 것이다. 그 의도와 맞지 않다면 어떤 것이든 생성자로 사용할 함수에는 적합하지 않다. 

```jsx
function Ninja() {
  this.skulk = function() {
    return this;
  };
}

const ninja1 = new Ninja();
const ninja2 = new Ninja();
console.log(ninja1.skulk() === ninja1); // true
console.log(ninja2.skulk() === ninja2); // true
```

위에서 닌자를 만드는 용도로 사용할 Ninja()라는 함수를 만들었다. new를 사용해서 이 함수를 호출하면, 빈 객체 인스턴스가 생성되고, 생성자 함수에 빈 객체 인스턴스가 this로 전달된다. 생성자 함수는 his 객체에 skulk라는 프로퍼티를 생성하고 함수를 할당한다. 결국 새로 생성된 객체는 skulk 프로퍼티를 갖게 된다. 

**생성자를 작성할 때 고려해야 할 것들**

생성자 함수는 특정한 상태로 초기화된 객체를 만들어 반환하기 위해서 사용한다. 그런데 이 생성자 함수를 '일반' 함수처럼 호출하는 것이 가능하다. 심지어 객체의 프로퍼티에 할당하여 메서드로 호출할 수도 있다. 

일반적으로 생성자는 다른 함수와는 다른 방식으로 작성하고 사용하기 때문에, 생성자는 생성자로 호출하지 않으면 쓸모가 없다. 

```jsx
const whatever = Ninja();
```

이 경우 window에 skulk 프로퍼티가 만들어지고, 반환 값은 window이며 window가 whatever 변수에 저장된다. 딱히 유용한 연산이 아니다. 

### 3.5 apply() 메서드와 call() 메서드를 사용한 호출

실행되는 함수에 this 매개변수가 암묵적으로 전달되는데, 이 this 값이 어떤 객체이고 결국 어떤 객체가 함수 콘텍스트가 되느냐가 각 함수 호출 방식의 주요 차이점이라는 것을 보았다. 메서드 호출의 경우, 함수 콘텍스트는 메서드를 소유하고 있는 객체이다. 최상위 함수의 경우, 함수 콘텍스트는 항상 window다. 생성자의 경우, 함수 콘텍스트는 새로 생성된 객체 인스턴스였다.

하지만 만약 this를 우리가 원하는 어떤 값으로 사용하고 싶다면 어떻게 할까? 만약 this를 명시적으로 설정하고 싶으면 어떻게 하는가? 

**apply()와 call() 메서드 사용하기**

자바스크립트는 함수를 호출할 때 어떤 객체든 명시적으로 함수 콘텍스트로 지정할 수 있는 수단을 제공한다. 모든 함수에 대해 apply(), call() 중 하나를 사용하여 함수 콘텍스트를 지정할 수 있다. 

apply()를 사용하려면 apply()에 두 개의 매개변수를 전달해야 한다. 하나는 함수 콘텍스트로 사용할 객체와 다른 하나는 인자값을 담은 배열이다. call()도 비슷하지만 인자를 배열로 전달하지 않고 인자 목록으로 직접 전달한다.

```jsx
function juggle() {
  let result = 0;
  for (let n = 0; n < arguments.length; n++) {
    result += arguments[n];
  }
  this.result = result;
}

const ninja1 = {};
const ninja2 = {};

juggle.apply(ninja1, [1, 2, 3, 4]);
juggle.call(ninja2, 5, 6, 7, 8);

console.log(ninja1.result === 10); // true
console.log(ninja2.result === 26); // true
```

위처럼 함수 호출 시에 임의의 객체를 함수 콘텍스트로 지정할 수 있음을 보여준다. 

**콜백의 함수 콘텍스트를 강제로 지정하기**

명령형 프로그래밍과 함수형 프로그래밍의 차이점은 함수를 단지 명령 구문으로만 취급하지 않고 프로그램 빌딩 블록으로 여기는 것에 있다. 

```jsx
// 명령형
function(collection) {
  for (let n = 0; n < collection.length; n++) {
		/* collection[n]에 대해 무엇인가를 한다. */ 
	}
}

// 함수형
function(item) {
	/* item에 대해 무엇인가를 한다. */
}
```

명령형 프로그래밍에서는 일반적으로 메서드에 배열을 전달하고, for 루프를 돌면서 각 배열 요소에 대해 연산을 수행한다. 반면 함수형 프로그래밍에서는, 요소 하나에 대한 연산을 하는 함수를 만들고, 모든 배열 요소를 각각 그 함수에 전달한다.

명령형 프로그래밍과 함수형 프로그래밍의 차이는 함수를 단지 명령 구문으로만 취급하지 않고 프로그램 빌딩 블록으로 여기는 것에 있다. 

forEach 함수는 함수형 프로그래밍에서 전통적인 for 구문보다 더 선호된다. 가장 중요한 포인트는 현재 요소를 콜백의 함수 콘텍스트로 지정하는 것이다. 

아래는 자바스크립트로 구현한 forEach 함수이다.

```jsx
function forEach(list, callback) {
  for (let n = 0; n < list.length; n++) {
    callback.call(list[n], n);
  }
}

const weapons = ['shuriken', 'katana', 'nunchucks'];

forEach(weapons, function(index) {
  console.log(this == weapons[index], weapons[index])
})

// true 'shuriken'
// true 'katana'
// true 'nunchucks'
```

## 4. 정리

- 자바스크립트가 함수형 언어라는 사실을 깨달아야 세련된 코드를 작성할 수 있다.
- 자바스크립트의 다른 모든 객체와 마찬가지로 함수는 1종 객체로 취급한다.

    다른 객체 타입과 마찬가지로, 함수에는 다음 특징이 있다.

    - 리터럴로 생성할 수 있다.
    - 변수나 프로퍼티에 할당할 수 있다.
    - 매개변수로 전달할 수 있다.
    - 함수의 결과로 반환될 수 있다.
    - 프로퍼티와 메서드를 가질 수 있다.
- 함수와 다른 객체와의 큰 차이는 호출할 수 있다는 점이다.
- 함수는 리터럴로 생성하며 이 때 함수 이름은 생략할 수 있다.
- 브라우저는 페이지가 로드되고 언로드 되기 전까지의 페이지 생명 주기 동안, 여러 형식의 이벤트에 대한 이벤트 핸들러를 호출하는데, 이 이벤트 핸들러를 호출하는 것이 곧 함수를 호출하는 것이다.
- 함수 내에서 선언된 타입의 유효 범위는 대부분의 다른 언어와 다르다.
    - 함수 내에 선언된 변수의 유효 범위는 변수가 선언된 지점으로부터 함수의 끝까지다. 블록 안에서 변수를 선언하더라도 그 변수는 변수를 선언한 지점부터 함수 끝부분까지 유효하다.
    - 이름이 지정된 내부 함수는 함수 내의 모든 곳에서 유효하다. (호이스팅)
- 함수의 매개변수 목록의 길이와 실제 전달된 인자 목록의 길이는 서로 다를 수 있다.
- 함수를 호출하면 암묵적으로 두 개의 매개변수가 전달된다. (arguments - 실제로 전달된 인자의 컬렉션, this - 함수 콘텍스트 객체를 참조)
- 함수를 호출하는 방식은 여러 가지이고, 각 호출 매커니즘에 따라 함수 콘텍스트 값이 결정된다. - 간단히 '함수로' 호출되면 함수 콘텍스트는 전역 객체이다.
    - '메서드'로 호출: 콘텍스트는 그 메서드를 소유한 객체이다.
    - '생성자'로 호출: 콘텍스트는 새로 생성된 객체이다.
    - 'apply() call()'로 호출: 콘텍스트는 어떤 객체든 원하는 것으로 지정할 수 있다.

